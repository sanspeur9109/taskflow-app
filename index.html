<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tailscale Todo App</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-blue: #3b82f6;
            --primary-indigo: #6366f1;
            --dark-bg: #0f172a;
            --dark-card: #1e293b;
            --dark-border: #334155;
            --text-light: #f8fafc;
            --text-dark: #0f172a;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --high-priority: #ef4444;
            --medium-priority: #f59e0b;
            --low-priority: #10b981;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, var(--primary-blue), var(--primary-indigo));
            min-height: 100vh;
            color: var(--text-light);
            transition: all 0.3s ease;
        }

        body.dark {
            background: linear-gradient(135deg, var(--dark-bg), #1e1b4b);
        }

        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sync-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--error);
            animation: pulse 2s infinite;
        }

        .status-dot.connected { background: var(--success); }
        .status-dot.syncing { background: var(--warning); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 30px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            background: rgba(255, 255, 255, 0.3);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary-blue), var(--primary-indigo));
        }

        .btn-archive {
            background: rgba(16, 185, 129, 0.3);
            border-color: rgba(16, 185, 129, 0.5);
        }

        .search-filter {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 30px;
        }

        .search-input, .filter-select, .sort-select {
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            backdrop-filter: blur(10px);
            flex: 1;
            min-width: 200px;
        }

        body:not(.dark) .search-input,
        body:not(.dark) .filter-select,
        body:not(.dark) .sort-select {
            color: var(--text-dark);
            background: white;
            border-color: #e2e8f0;
        }

        body.dark .search-input,
        body.dark .filter-select,
        body.dark .sort-select {
            color: var(--text-light);
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .filter-select option,
        .sort-select option {
            background-color: white;
            color: var(--text-dark);
        }

        body.dark .filter-select option,
        body.dark .sort-select option {
            background-color: var(--dark-card);
            color: var(--text-light);
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        /* List View Styles */
        .todo-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 30px;
        }

        .todo-list .todo-card {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .todo-list .todo-card:hover {
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .todo-list .todo-card.completed {
            opacity: 0.7;
            background: rgba(16, 185, 129, 0.1);
        }

        .todo-list .priority-bar {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            height: 100%;
        }

        .todo-list .todo-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            margin-left: 10px;
        }

        .todo-list .todo-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .todo-list .todo-meta {
            display: flex;
            gap: 8px;
            font-size: 11px;
            opacity: 0.8;
            flex-wrap: wrap;
        }

        .todo-list .todo-meta .meta-item {
            padding: 3px 6px;
            border-radius: 8px;
        }

        .todo-list .todo-actions {
            display: flex;
            gap: 5px;
            margin-left: auto;
            flex-shrink: 0;
        }

        .todo-list .action-btn {
            padding: 6px 10px;
            font-size: 11px;
        }

        /* Grid View Styles */
        .todo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .todo-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            padding: 20px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .todo-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .todo-card.completed {
            opacity: 0.7;
            background: rgba(16, 185, 129, 0.1);
        }

        .priority-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
        }

        .priority-high { background: var(--high-priority); }
        .priority-medium { background: var(--medium-priority); }
        .priority-low { background: var(--low-priority); }

        .todo-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
        }

        .todo-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            line-height: 1.4;
        }

        .todo-meta {
            display: flex;
            gap: 10px;
            font-size: 12px;
            opacity: 0.8;
            flex-wrap: wrap;
        }

        .meta-item {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 12px;
        }

        .overdue {
            background: var(--error) !important;
            color: white !important;
        }

        .todo-actions {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        .action-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
            background: rgba(255, 255, 255, 0.2);
            color: white;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .subtasks {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .subtask {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            font-size: 14px;
        }

        .subtask input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            color: var(--text-dark);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-dark);
        }

        .form-input, .form-textarea, .form-select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            color: var(--text-dark);
        }

        .form-input:focus, .form-textarea:focus, .form-select:focus {
            outline: none;
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .drag-drop-area {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            transition: all 0.3s ease;
            background: #f8fafc;
            margin-bottom: 20px;
        }

        .drag-drop-area.dragover {
            border-color: var(--primary-blue);
            background: rgba(59, 130, 246, 0.1);
        }

        .progress-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .progress-bar {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            height: 8px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--primary-blue));
            transition: width 0.3s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-number {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary-blue);
        }

        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .success-message {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #86efac;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .theme-toggle {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            .controls, .search-filter {
                flex-direction: column;
            }

            .todo-grid {
                grid-template-columns: 1fr;
            }

            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="logo">
                📋 Tailscale Todo
            </div>
            <div class="sync-status">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Disconnected</span>
                <button class="theme-toggle" onclick="toggleTheme()">🌙</button>
                <button class="btn" onclick="openTailscaleModal()">⚙️ Setup</button>
            </div>
        </header>

        <div class="progress-section">
            <h3 id="progressTitle">Progress Overview</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="overallProgress"></div>
            </div>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number" id="totalTasks">0</div>
                    <div>Total Tasks</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="completedTasks">0</div>
                    <div>Completed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="pendingTasks">0</div>
                    <div>Pending</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="overdueTasks">0</div>
                    <div>Overdue</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="openTaskModal()">+ Add Task</button>
            <button class="btn" onclick="openImportModal()">📊 Import Excel</button>
            <button class="btn" onclick="exportToExcel()">📥 Export Excel</button>
            <button class="btn" onclick="syncData()">🔄 Sync Now</button>
            <button class="btn" id="toggleViewBtn" onclick="toggleView()">Switch to List View</button>
            <button class="btn" id="archiveToggleBtn" onclick="toggleArchiveView()">Show Archived</button>
            <button class="btn btn-archive" onclick="archiveCompletedTasks()">📦 Archive Completed</button>
        </div>

        <div class="search-filter">
            <input type="text" class="search-input" placeholder="Search tasks..." id="searchInput" onkeyup="filterTasks()">
            <select class="filter-select" id="priorityFilter" onchange="filterTasks()">
                <option value="">All Priorities</option>
                <option value="high">High Priority</option>
                <option value="medium">Medium Priority</option>
                <option value="low">Low Priority</option>
            </select>
            <select class="filter-select" id="statusFilter" onchange="filterTasks()">
                <option value="">All Status</option>
                <option value="pending">Pending</option>
                <option value="completed">Completed</option>
                <option value="overdue">Overdue</option>
            </select>
            <select class="filter-select" id="categoryFilter" onchange="filterTasks()">
                <option value="">All Categories</option>
            </select>
            <select class="sort-select" id="sortSelect" onchange="sortAndRenderTasks()">
                <option value="createdAtDesc">Newest First</option>
                <option value="createdAtAsc">Oldest First</option>
                <option value="titleAsc">Title (A-Z)</option>
                <option value="titleDesc">Title (Z-A)</option>
                <option value="priorityHigh">Priority (High to Low)</option>
                <option value="priorityLow">Priority (Low to High)</option>
            </select>
        </div>

        <div id="todoDisplayArea"></div>
    </div>

    <!-- Task Modal -->
    <div class="modal" id="taskModal">
        <div class="modal-content">
            <h2 id="modalTitle">Add New Task</h2>
            <div id="taskForm">
                <div class="form-group">
                    <label class="form-label">Title *</label>
                    <input type="text" class="form-input" id="taskTitle" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-textarea" id="taskDescription" rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Priority</label>
                    <select class="form-select" id="taskPriority">
                        <option value="low">Low</option>
                        <option value="medium">Medium</option>
                        <option value="high">High</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Category</label>
                    <input type="text" class="form-input" id="taskCategory" placeholder="e.g., Work, Personal">
                </div>
                <div class="form-group">
                    <label class="form-label">Due Date</label>
                    <input type="date" class="form-input" id="taskDueDate">
                </div>
                <div class="form-group">
                    <label class="form-label">Subtasks (one per line)</label>
                    <textarea class="form-textarea" id="taskSubtasks" rows="3" placeholder="Subtask 1&#10;Subtask 2"></textarea>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="saveTask()">Save Task</button>
                    <button class="btn" onclick="closeModal('taskModal')">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div class="modal" id="importModal">
        <div class="modal-content">
            <h2>Import from Excel</h2>
            <div class="drag-drop-area" id="dragDropArea">
                <p>📊 Drag & drop your Excel file here</p>
                <p>or <strong>click to browse</strong></p>
                <input type="file" id="excelFile" accept=".xlsx,.xls" style="display: none;">
            </div>
            <div id="importPreview" style="display: none;">
                <h3>Import Preview</h3>
                <div id="previewContent"></div>
                <div style="margin-top: 20px;">
                    <button class="btn btn-primary" onclick="confirmImport()">Import Tasks</button>
                    <button class="btn" onclick="cancelImport()">Cancel</button>
                </div>
            </div>
            <div style="margin-top: 20px;">
                <button class="btn" onclick="closeModal('importModal')">Close</button>
            </div>
        </div>
    </div>

    <!-- Tailscale Configuration Modal -->
    <div class="modal" id="tailscaleModal">
        <div class="modal-content">
            <h2>Tailscale Configuration</h2>
            <div class="form-group">
                <label class="form-label">Tailscale Node URL</label>
                <input type="text" class="form-input" id="tailscaleUrl" placeholder="https://your-device.tailnet.ts.net">
            </div>
            <div class="form-group">
                <label class="form-label">Access Key (Optional)</label>
                <input type="password" class="form-input" id="tailscaleKey" placeholder="Your Tailscale access key">
            </div>
            <div class="form-group">
                <label class="form-label">Sync Interval (seconds)</label>
                <input type="number" class="form-input" id="syncInterval" value="30" min="10">
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-primary" onclick="saveTailscaleConfig()">Save & Connect</button>
                <button class="btn" onclick="closeModal('tailscaleModal')">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Application State
        let appState = {
            tasks: [],
            archivedTasks: [],
            currentEditId: null,
            tailscaleConfig: {
                url: '',
                key: '',
                interval: 30000
            },
            syncStatus: 'disconnected',
            categories: new Set(),
            darkMode: false,
            currentView: 'grid',
            currentSort: 'createdAtDesc',
            showArchived: false
        };

        let syncTimer;

        // Utility Functions
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatDate(dateString) {
            if (!dateString) return '';
            try {
                const date = new Date(dateString);
                return date.toLocaleDateString();
            } catch (e) {
                console.error("Error formatting date:", e);
                return '';
            }
        }

        function formatDateTime(dateString) {
            if (!dateString) return '';
            try {
                const date = new Date(dateString);
                return date.toLocaleString();
            } catch (e) {
                console.error("Error formatting datetime:", e);
                return '';
            }
        }

        function showMessage(message, type = 'info') {
            const className = type === 'error' ? 'error-message' : 'success-message';
            
            document.querySelectorAll('.error-message, .success-message').forEach(el => el.remove());
            
            const messageEl = document.createElement('div');
            messageEl.className = className;
            messageEl.textContent = message;
            
            const container = document.querySelector('.app-container');
            if (container) {
                container.insertBefore(messageEl, document.querySelector('.progress-section'));
                setTimeout(() => {
                    messageEl.remove();
                }, 5000);
            }
        }

        // Data Management
        function loadData() {
            try {
                const saved = JSON.parse(window.localStorage.getItem('todoAppData')) || {};
                appState.tasks = saved.tasks || [];
                appState.archivedTasks = saved.archivedTasks || [];
                appState.tailscaleConfig = saved.tailscaleConfig || appState.tailscaleConfig;
                appState.darkMode = saved.darkMode || false;
                appState.currentView = saved.currentView || 'grid';
                appState.currentSort = saved.currentSort || 'createdAtDesc';
                appState.showArchived = saved.showArchived || false;
                
                // Populate categories from loaded tasks
                appState.categories.clear();
                [...appState.tasks, ...appState.archivedTasks].forEach(task => {
                    if (task.category) {
                        appState.categories.add(task.category);
                    }
                });

                // Apply theme
                if (appState.darkMode) {
                    document.body.classList.add('dark');
                }
                
                console.log('Data loaded successfully');
            } catch (error) {
                console.warn('Failed to load data:', error);
            }
        }

        function saveData() {
            try {
                window.localStorage.setItem('todoAppData', JSON.stringify({
                    tasks: appState.tasks,
                    archivedTasks: appState.archivedTasks,
                    tailscaleConfig: appState.tailscaleConfig,
                    darkMode: appState.darkMode,
                    currentView: appState.currentView,
                    currentSort: appState.currentSort,
                    showArchived: appState.showArchived
                }));
                console.log('Data saved successfully');
            } catch (error) {
                console.warn('Failed to save data:', error);
            }
        }

        function loadSampleData() {
            const sampleTasks = [
                {
                    id: generateId(),
                    title: 'Setup Tailscale Configuration',
                    description: 'Configure Tailscale settings to enable cross-device synchronization',
                    priority: 'high',
                    category: 'Setup',
                    dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    completed: false,
                    subtasks: [
                        { id: generateId(), title: 'Install Tailscale on all devices', completed: false },
                        { id: generateId(), title: 'Configure network settings', completed: false },
                        { id: generateId(), title: 'Test connectivity', completed: false }
                    ],
                    createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
                    updatedAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString()
                },
                {
                    id: generateId(),
                    title: 'Buy groceries for the week',
                    description: 'Milk, Eggs, Bread, Vegetables',
                    priority: 'low',
                    category: 'Personal',
                    dueDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    completed: false,
                    subtasks: [],
                    createdAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),
                    updatedAt: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString()
                },
                {
                    id: generateId(),
                    title: 'Prepare presentation for client meeting',
                    description: 'Finalize slides, rehearse, prepare Q&A',
                    priority: 'high',
                    category: 'Work',
                    dueDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    completed: false,
                    subtasks: [
                        { id: generateId(), title: 'Review last quarter sales data', completed: true },
                        { id: generateId(), title: 'Create new slide deck', completed: false }
                    ],
                    createdAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
                    updatedAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()
                },
                {
                    id: generateId(),
                    title: 'Call Grandma',
                    description: '',
                    priority: 'low',
                    category: 'Personal',
                    dueDate: '',
                    completed: true,
                    subtasks: [],
                    createdAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
                    updatedAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString()
                }
            ];

            appState.tasks = sampleTasks;
            appState.categories.add('Setup');
            appState.categories.add('Personal');
            appState.categories.add('Work');
            saveData();
        }

        // Task Management Functions
        function openTaskModal(taskId = null) {
            const modal = document.getElementById('taskModal');
            const title = document.getElementById('modalTitle');
            
            if (taskId) {
                const task = appState.tasks.find(t => t.id === taskId) || 
                            appState.archivedTasks.find(t => t.id === taskId);
                if (task) {
                    title.textContent = 'Edit Task';
                    document.getElementById('taskTitle').value = task.title;
                    document.getElementById('taskDescription').value = task.description || '';
                    document.getElementById('taskPriority').value = task.priority;
                    document.getElementById('taskCategory').value = task.category || '';
                    document.getElementById('taskDueDate').value = task.dueDate || '';
                    document.getElementById('taskSubtasks').value = task.subtasks ? task.subtasks.map(s => s.title).join('\n') : '';
                    appState.currentEditId = taskId;
                }
            } else {
                title.textContent = 'Add New Task';
                document.getElementById('taskTitle').value = '';
                document.getElementById('taskDescription').value = '';
                document.getElementById('taskPriority').value = 'medium';
                document.getElementById('taskCategory').value = '';
                document.getElementById('taskDueDate').value = '';
                document.getElementById('taskSubtasks').value = '';
                appState.currentEditId = null;
            }
            
            modal.classList.add('active');
        }

        function saveTask() {
            const title = document.getElementById('taskTitle').value.trim();
            const description = document.getElementById('taskDescription').value.trim();
            const priority = document.getElementById('taskPriority').value;
            const category = document.getElementById('taskCategory').value.trim();
            const dueDate = document.getElementById('taskDueDate').value;
            const subtasksText = document.getElementById('taskSubtasks').value.trim();

            if (!title) {
                showMessage('Please enter a task title', 'error');
                return;
            }

            const subtasks = subtasksText ? subtasksText.split('\n').filter(s => s.trim()).map(s => ({
                id: generateId(),
                title: s.trim(),
                completed: false
            })) : [];

            const taskData = {
                title,
                description,
                priority,
                category,
                dueDate,
                subtasks,
                completed: false,
                updatedAt: new Date().toISOString()
            };

            if (appState.currentEditId) {
                const activeIndex = appState.tasks.findIndex(t => t.id === appState.currentEditId);
                const archivedIndex = appState.archivedTasks.findIndex(t => t.id === appState.currentEditId);
                
                if (activeIndex !== -1) {
                    appState.tasks[activeIndex] = { ...appState.tasks[activeIndex], ...taskData };
                } else if (archivedIndex !== -1) {
                    appState.archivedTasks[archivedIndex] = { ...appState.archivedTasks[archivedIndex], ...taskData };
                }
            } else {
                taskData.id = generateId();
                taskData.createdAt = new Date().toISOString();
                appState.tasks.push(taskData);
            }

            if (category) {
                appState.categories.add(category);
            }

            saveData();
            updateCategoryFilter();
            sortAndRenderTasks();
            updateStats();
            closeModal('taskModal');
            showMessage('Task saved successfully!', 'success');
        }

        function deleteTask(taskId) {
            if (confirm('Are you sure you want to delete this task?')) {
                appState.tasks = appState.tasks.filter(t => t.id !== taskId);
                appState.archivedTasks = appState.archivedTasks.filter(t => t.id !== taskId);
                saveData();
                sortAndRenderTasks();
                updateStats();
                showMessage('Task deleted successfully!', 'success');
            }
        }

        function toggleTask(taskId) {
            if (appState.showArchived) return;
            
            const task = appState.tasks.find(t => t.id === taskId);
            if (task) {
                task.completed = !task.completed;
                task.updatedAt = new Date().toISOString();
                saveData();
                sortAndRenderTasks();
                updateStats();
            }
        }

        function toggleSubtask(taskId, subtaskId) {
            const task = appState.tasks.find(t => t.id === taskId) || 
                        appState.archivedTasks.find(t => t.id === taskId);
            if (task && task.subtasks) {
                const subtask = task.subtasks.find(s => s.id === subtaskId);
                if (subtask) {
                    subtask.completed = !subtask.completed;
                    task.updatedAt = new Date().toISOString();
                    saveData();
                    sortAndRenderTasks();
                    updateStats();
                }
            }
        }

        // Archive Functions
        function archiveTask(taskId) {
            const taskIndex = appState.tasks.findIndex(t => t.id === taskId);
            if (taskIndex !== -1) {
                const task = appState.tasks[taskIndex];
                task.archivedAt = new Date().toISOString();
                appState.archivedTasks.push(task);
                appState.tasks.splice(taskIndex, 1);
                saveData();
                sortAndRenderTasks();
                updateStats();
                showMessage('Task archived successfully!', 'success');
            }
        }

        function unarchiveTask(taskId) {
            const taskIndex = appState.archivedTasks.findIndex(t => t.id === taskId);
            if (taskIndex !== -1) {
                const task = appState.archivedTasks[taskIndex];
                delete task.archivedAt;
                task.updatedAt = new Date().toISOString();
                appState.tasks.push(task);
                appState.archivedTasks.splice(taskIndex, 1);
                saveData();
                sortAndRenderTasks();
                updateStats();
                showMessage('Task unarchived successfully!', 'success');
            }
        }

        function archiveCompletedTasks() {
            const completedTasks = appState.tasks.filter(t => t.completed);
            if (completedTasks.length === 0) {
                showMessage('No completed tasks to archive', 'error');
                return;
            }

            if (confirm(`Archive ${completedTasks.length} completed task(s)?`)) {
                completedTasks.forEach(task => {
                    task.archivedAt = new Date().toISOString();
                    appState.archivedTasks.push(task);
                });
                
                appState.tasks = appState.tasks.filter(t => !t.completed);
                saveData();
                sortAndRenderTasks();
                updateStats();
                showMessage(`${completedTasks.length} completed task(s) archived successfully!`, 'success');
            }
        }

        function toggleArchiveView() {
            appState.showArchived = !appState.showArchived;
            saveData();
            updateArchiveToggleButton();
            sortAndRenderTasks();
            updateStats();
        }

        function updateArchiveToggleButton() {
            const button = document.getElementById('archiveToggleBtn');
            button.textContent = appState.showArchived ? 'Show Active Tasks' : 'Show Archived';
        }

        // Sorting and Filtering
        function sortTasks(tasks) {
            const sortCriteria = appState.currentSort;
            const priorityOrder = { 'high': 3, 'medium': 2, 'low': 1 };

            tasks.sort((a, b) => {
                switch (sortCriteria) {
                    case 'createdAtAsc':
                        return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
                    case 'createdAtDesc':
                        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
                    case 'titleAsc':
                        return a.title.localeCompare(b.title);
                    case 'titleDesc':
                        return b.title.localeCompare(a.title);
                    case 'priorityHigh':
                        return priorityOrder[b.priority] - priorityOrder[a.priority];
                    case 'priorityLow':
                        return priorityOrder[a.priority] - priorityOrder[b.priority];
                    default:
                        return 0;
                }
            });
            return tasks;
        }

        function getFilteredTasks() {
            const search = document.getElementById('searchInput').value.toLowerCase();
            const priorityFilter = document.getElementById('priorityFilter').value;
            const statusFilter = document.getElementById('statusFilter').value;
            const categoryFilter = document.getElementById('categoryFilter').value;

            const tasksToFilter = appState.showArchived ? appState.archivedTasks : appState.tasks;

            return tasksToFilter.filter(task => {
                const matchesSearch = !search || 
                    task.title.toLowerCase().includes(search) ||
                    (task.description && task.description.toLowerCase().includes(search)) ||
                    (task.category && task.category.toLowerCase().includes(search));

                const matchesPriority = !priorityFilter || task.priority === priorityFilter;
                const matchesCategory = !categoryFilter || task.category === categoryFilter;

                let matchesStatus = true;
                if (statusFilter === 'completed') {
                    matchesStatus = task.completed;
                } else if (statusFilter === 'pending') {
                    matchesStatus = !task.completed;
                } else if (statusFilter === 'overdue') {
                    matchesStatus = task.dueDate && new Date(task.dueDate) < new Date() && !task.completed;
                }

                return matchesSearch && matchesPriority && matchesCategory && matchesStatus;
            });
        }

        function filterTasks() {
            sortAndRenderTasks();
        }

        function sortAndRenderTasks() {
            appState.currentSort = document.getElementById('sortSelect').value;
            saveData();
            renderTasks();
        }

        // Rendering
        function renderTasks() {
            const displayArea = document.getElementById('todoDisplayArea');
            const filteredAndSortedTasks = sortTasks(getFilteredTasks());

            if (filteredAndSortedTasks.length === 0) {
                const emptyMessage = appState.showArchived ? 
                    'No archived tasks found.' : 
                    'No tasks found. Add your first task to get started!';
                displayArea.innerHTML = `<div style="text-align: center; padding: 40px; opacity: 0.7;">${emptyMessage}</div>`;
                return;
            }

            let html = '';
            if (appState.currentView === 'grid') {
                html = `<div class="todo-grid">`;
                html += filteredAndSortedTasks.map(task => renderTaskCard(task)).join('');
                html += `</div>`;
            } else {
                html = `<div class="todo-list">`;
                html += filteredAndSortedTasks.map(task => renderTaskListItem(task)).join('');
                html += `</div>`;
            }

            displayArea.innerHTML = html;
        }

        function renderTaskCard(task) {
            const isOverdue = task.dueDate && new Date(task.dueDate) < new Date() && !task.completed;
            const subtaskProgress = task.subtasks && task.subtasks.length > 0 ? 
                (task.subtasks.filter(s => s.completed).length / task.subtasks.length) * 100 : 0;

            return `
                <div class="todo-card ${task.completed ? 'completed' : ''}" data-task-id="${task.id}">
                    <div class="priority-bar priority-${task.priority}"></div>
                    <div class="todo-header">
                        <div>
                            <div class="todo-title">${escapeHtml(task.title)}</div>
                            <div class="todo-meta">
                                <span class="meta-item priority-${task.priority}">${task.priority.toUpperCase()}</span>
                                ${task.category ? `<span class="meta-item">${escapeHtml(task.category)}</span>` : ''}
                                ${task.dueDate ? `<span class="meta-item ${isOverdue ? 'overdue' : ''}">${formatDate(task.dueDate)}</span>` : ''}
                                ${isOverdue ? '<span class="meta-item overdue">OVERDUE</span>' : ''}
                                ${appState.showArchived ? '<span class="meta-item" style="background: rgba(100, 100, 100, 0.5);">ARCHIVED</span>' : ''}
                            </div>
                        </div>
                    </div>
                    ${task.description ? `<p style="margin-bottom: 15px; opacity: 0.9;">${escapeHtml(task.description)}</p>` : ''}
                    
                    ${task.subtasks && task.subtasks.length > 0 ? `
                        <div class="subtasks">
                            <div style="font-size: 12px; margin-bottom: 10px; opacity: 0.8;">
                                Subtasks: ${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length}
                                <div class="progress-bar" style="height: 4px; margin-top: 5px;">
                                    <div class="progress-fill" style="width: ${subtaskProgress}%;"></div>
                                </div>
                            </div>
                            ${task.subtasks.map(subtask => `
                                <div class="subtask">
                                    <input type="checkbox" ${subtask.completed ? 'checked' : ''} 
                                           onchange="toggleSubtask('${task.id}', '${subtask.id}')">
                                    <span style="${subtask.completed ? 'text-decoration: line-through; opacity: 0.6;' : ''}">${escapeHtml(subtask.title)}</span>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    <div class="todo-actions">
                        ${appState.showArchived ? `
                            <button class="action-btn" onclick="unarchiveTask('${task.id}')" style="background: rgba(16, 185, 129, 0.3);">📤 Unarchive</button>
                        ` : `
                            <button class="action-btn" onclick="toggleTask('${task.id}')">
                                ${task.completed ? '↩️ Undo' : '✅ Complete'}
                            </button>
                            <button class="action-btn" onclick="archiveTask('${task.id}')" style="background: rgba(100, 100, 100, 0.3);">📦 Archive</button>
                        `}
                        <button class="action-btn" onclick="openTaskModal('${task.id}')">✏️ Edit</button>
                        <button class="action-btn" onclick="deleteTask('${task.id}')">🗑️ Delete</button>
                    </div>
                </div>
            `;
        }

        function renderTaskListItem(task) {
            const isOverdue = task.dueDate && new Date(task.dueDate) < new Date() && !task.completed;

            return `
                <div class="todo-card ${task.completed ? 'completed' : ''}" data-task-id="${task.id}">
                    <div class="priority-bar priority-${task.priority}"></div>
                    <div class="todo-content">
                        <div class="todo-title">${escapeHtml(task.title)}</div>
                        <div class="todo-meta">
                            <span class="meta-item priority-${task.priority}">${task.priority.toUpperCase()}</span>
                            ${task.category ? `<span class="meta-item">${escapeHtml(task.category)}</span>` : ''}
                            ${task.dueDate ? `<span class="meta-item ${isOverdue ? 'overdue' : ''}">${formatDate(task.dueDate)}</span>` : ''}
                            ${isOverdue ? '<span class="meta-item overdue">OVERDUE</span>' : ''}
                            ${task.subtasks && task.subtasks.length > 0 ? `<span class="meta-item">Subtasks: ${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length}</span>` : ''}
                            ${task.description ? `<span class="meta-item">Description: ${escapeHtml(task.description.substring(0, 50))}...</span>` : ''}
                            ${appState.showArchived ? '<span class="meta-item" style="background: rgba(100, 100, 100, 0.5);">ARCHIVED</span>' : ''}
                        </div>
                    </div>
                    <div class="todo-actions">
                        ${appState.showArchived ? `
                            <button class="action-btn" onclick="unarchiveTask('${task.id}')" style="background: rgba(16, 185, 129, 0.3);">📤</button>
                        ` : `
                            <button class="action-btn" onclick="toggleTask('${task.id}')">
                                ${task.completed ? '↩️' : '✅'}
                            </button>
                            <button class="action-btn" onclick="archiveTask('${task.id}')" style="background: rgba(100, 100, 100, 0.3);">📦</button>
                        `}
                        <button class="action-btn" onclick="openTaskModal('${task.id}')">✏️</button>
                        <button class="action-btn" onclick="deleteTask('${task.id}')">🗑️</button>
                    </div>
                </div>
            `;
        }

        // Statistics and UI Updates
        function updateStats() {
            let activeTasks, archivedCount;
            
            if (appState.showArchived) {
                activeTasks = appState.archivedTasks;
                archivedCount = activeTasks.length;
            } else {
                activeTasks = appState.tasks;
                archivedCount = appState.archivedTasks.length;
            }
            
            const total = activeTasks.length;
            const completed = activeTasks.filter(t => t.completed).length;
            const pending = total - completed;
            const overdue = activeTasks.filter(t => 
                t.dueDate && new Date(t.dueDate) < new Date() && !t.completed
            ).length;

            document.getElementById('totalTasks').textContent = total;
            document.getElementById('completedTasks').textContent = completed;
            document.getElementById('pendingTasks').textContent = pending;
            document.getElementById('overdueTasks').textContent = overdue;

            const progress = total > 0 ? (completed / total) * 100 : 0;
            document.getElementById('overallProgress').style.width = `${progress}%`;
            
            const statsTitle = document.getElementById('progressTitle');
            if (statsTitle) {
                statsTitle.textContent = appState.showArchived ? 
                    `Archived Tasks Overview (${archivedCount} archived)` : 
                    `Progress Overview (${archivedCount} archived)`;
            }
        }

        function updateCategoryFilter() {
            const select = document.getElementById('categoryFilter');
            const currentValue = select.value;
            
            select.innerHTML = '<option value="">All Categories</option>';
            Array.from(appState.categories).sort().forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                select.appendChild(option);
            });
            
            select.value = currentValue;
        }

        // View Management
        function toggleView() {
            appState.currentView = appState.currentView === 'grid' ? 'list' : 'grid';
            saveData();
            updateToggleViewButton();
            renderTasks();
        }

        function updateToggleViewButton() {
            const button = document.getElementById('toggleViewBtn');
            button.textContent = appState.currentView === 'grid' ? 'Switch to List View' : 'Switch to Grid View';
        }

        function toggleTheme() {
            appState.darkMode = !appState.darkMode;
            document.body.classList.toggle('dark', appState.darkMode);
            saveData();
            
            const button = document.querySelector('.theme-toggle');
            button.textContent = appState.darkMode ? '☀️' : '🌙';
        }

        // Modal Management
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        // Excel Import/Export Functions
        function openImportModal() {
            document.getElementById('importModal').classList.add('active');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                processExcelFile(files[0]);
            }
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                processExcelFile(files[0]);
            }
        }

        function processExcelFile(file) {
            if (!file.name.match(/\.(xlsx|xls)$/)) {
                showMessage('Please select a valid Excel file (.xlsx or .xls)', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);

                    if (jsonData.length === 0) {
                        showMessage('The Excel file appears to be empty', 'error');
                        return;
                    }

                    parseExcelData(jsonData);
                } catch (error) {
                    console.error('Error processing Excel file:', error);
                    showMessage('Error reading Excel file. Please check the file format.', 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function parseExcelData(data) {
            const preview = document.getElementById('importPreview');
            const content = document.getElementById('previewContent');
            
            const columnMap = detectColumns(data[0]);
            
            const parsedTasks = data.map((row, index) => {
                const task = {
                    id: generateId(),
                    title: getColumnValue(row, columnMap.title) || `Imported Task ${index + 1}`,
                    description: getColumnValue(row, columnMap.description) || '',
                    priority: mapPriority(getColumnValue(row, columnMap.priority)) || 'medium',
                    category: getColumnValue(row, columnMap.category) || '',
                    dueDate: parseDate(getColumnValue(row, columnMap.dueDate)) || '',
                    completed: parseBoolean(getColumnValue(row, columnMap.completed)) || false,
                    subtasks: [],
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };

                const subtasksText = getColumnValue(row, columnMap.subtasks);
                if (subtasksText) {
                    task.subtasks = subtasksText.split(/[;\n,]/).filter(s => s.trim()).map(s => ({
                        id: generateId(),
                        title: s.trim(),
                        completed: false
                    }));
                }

                return task;
            }).filter(task => task.title.trim());

            window.importPreviewData = parsedTasks;

            content.innerHTML = `
                <div class="success-message">
                    Found ${parsedTasks.length} tasks ready to import
                </div>
                <div style="max-height: 300px; overflow-y: auto; border: 1px solid #e2e8f0; border-radius: 8px; padding: 15px;">
                    ${parsedTasks.slice(0, 5).map(task => `
                        <div style="padding: 10px; border-bottom: 1px solid #e2e8f0; margin-bottom: 10px;">
                            <strong>${escapeHtml(task.title)}</strong><br>
                            <small>Priority: ${task.priority} | Category: ${task.category || 'None'} | Due: ${task.dueDate || 'None'}</small>
                            ${task.subtasks.length > 0 ? `<br><small>Subtasks: ${task.subtasks.length}</small>` : ''}
                        </div>
                    `).join('')}
                    ${parsedTasks.length > 5 ? `<div style="text-align: center; opacity: 0.7;">... and ${parsedTasks.length - 5} more tasks</div>` : ''}
                </div>
            `;

            preview.style.display = 'block';
        }

        function detectColumns(firstRow) {
            const columns = Object.keys(firstRow);
            const map = {};

            const patterns = {
                title: /^(title|task|name|item|todo|subject)$/i,
                description: /^(description|desc|details|notes|comment)$/i,
                priority: /^(priority|pri|importance|urgency)$/i,
                category: /^(category|cat|type|group|project)$/i,
                dueDate: /^(due|date|deadline|end|finish)$/i,
                completed: /^(completed|done|finished|status)$/i,
                subtasks: /^(subtasks|sub|children|items)$/i
            };

            Object.keys(patterns).forEach(key => {
                map[key] = columns.find(col => patterns[key].test(col)) || columns[0];
            });

            return map;
        }

        function getColumnValue(row, column) {
            return row[column] || '';
        }

        function mapPriority(value) {
            if (!value) return 'medium';
            const val = value.toString().toLowerCase();
            if (val.includes('high') || val.includes('urgent') || val === '3' || val === 'h') return 'high';
            if (val.includes('low') || val === '1' || val === 'l') return 'low';
            return 'medium';
        }

        function parseDate(value) {
            if (!value) return '';
            try {
                const date = new Date(value);
                if (isNaN(date.getTime())) {
                    return ''; 
                }
                return date.toISOString().split('T')[0];
            } catch {
                return '';
            }
        }

        function parseBoolean(value) {
            if (!value) return false;
            const val = value.toString().toLowerCase();
            return val === 'true' || val === 'yes' || val === '1' || val === 'completed' || val === 'done';
        }

        function confirmImport() {
            if (window.importPreviewData) {
                appState.tasks = [...appState.tasks, ...window.importPreviewData];
                
                window.importPreviewData.forEach(task => {
                    if (task.category) {
                        appState.categories.add(task.category);
                    }
                });

                saveData();
                updateCategoryFilter();
                sortAndRenderTasks();
                updateStats();
                closeModal('importModal');
                showMessage(`Successfully imported ${window.importPreviewData.length} tasks!`, 'success');
                window.importPreviewData = null;
            }
        }

        function cancelImport() {
            document.getElementById('importPreview').style.display = 'none';
            window.importPreviewData = null;
        }

        function exportToExcel() {
            const tasksToExport = appState.showArchived ? appState.archivedTasks : appState.tasks;
            
            if (tasksToExport.length === 0) {
                showMessage('No tasks to export', 'error');
                return;
            }

            const exportData = tasksToExport.map(task => ({
                Title: task.title,
                Description: task.description || '',
                Priority: task.priority,
                Category: task.category || '',
                'Due Date': task.dueDate || '',
                Completed: task.completed ? 'Yes' : 'No',
                Subtasks: task.subtasks ? task.subtasks.map(s => s.title).join('; ') : '',
                'Created At': formatDateTime(task.createdAt),
                'Updated At': formatDateTime(task.updatedAt),
                'Archived At': task.archivedAt ? formatDateTime(task.archivedAt) : ''
            }));

            const worksheet = XLSX.utils.json_to_sheet(exportData);
            const workbook = XLSX.utils.book_new();
            const sheetName = appState.showArchived ? 'Archived Tasks' : 'Active Tasks';
            XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);

            const filePrefix = appState.showArchived ? 'archived-tasks' : 'todo-export';
            const fileName = `${filePrefix}-${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(workbook, fileName);
            
            showMessage('Tasks exported successfully!', 'success');
        }

        // Tailscale Sync Functions
        function openTailscaleModal() {
            const modal = document.getElementById('tailscaleModal');
            document.getElementById('tailscaleUrl').value = appState.tailscaleConfig.url;
            document.getElementById('tailscaleKey').value = appState.tailscaleConfig.key;
            document.getElementById('syncInterval').value = appState.tailscaleConfig.interval / 1000;
            modal.classList.add('active');
        }

        function saveTailscaleConfig() {
            const url = document.getElementById('tailscaleUrl').value.trim();
            const key = document.getElementById('tailscaleKey').value.trim();
            const interval = parseInt(document.getElementById('syncInterval').value) * 1000;

            if (!url) {
                showMessage('Please enter a Tailscale node URL', 'error');
                return;
            }

            if (!url.startsWith('http')) {
                showMessage('URL must start with http:// or https://', 'error');
                return;
            }

            appState.tailscaleConfig = { url, key, interval };
            saveData();
            closeModal('tailscaleModal');
            
            startTailscaleSync();
            showMessage('Tailscale configuration saved!', 'success');
        }

        function startTailscaleSync() {
            if (syncTimer) {
                clearInterval(syncTimer);
            }

            updateSyncStatus('connecting');
            
            setTimeout(() => {
                updateSyncStatus('connected');
                
                syncTimer = setInterval(() => {
                    syncData();
                }, appState.tailscaleConfig.interval);
                
                console.log('Tailscale sync started with interval:', appState.tailscaleConfig.interval / 1000, 'seconds');
            }, 2000);
        }

        function syncData() {
            if (!appState.tailscaleConfig.url) {
                console.warn('Tailscale not configured, skipping sync.');
                updateSyncStatus('disconnected');
                return;
            }

            updateSyncStatus('syncing');
            console.log('Attempting to sync data with Tailscale node:', appState.tailscaleConfig.url);

            simulateTailscaleSync()
                .then(() => {
                    updateSyncStatus('connected');
                    showMessage('Sync completed!', 'success');
                })
                .catch(error => {
                    updateSyncStatus('error');
                    console.error('Tailscale sync failed:', error);
                    showMessage('Sync failed. Check console for details.', 'error');
                });
        }

        function simulateTailscaleSync() {
            return new Promise((resolve, reject) => {
                const isSuccess = Math.random() > 0.1;
                setTimeout(() => {
                    if (isSuccess) {
                        resolve();
                    } else {
                        reject(new Error('Simulated network or API error.'));
                    }
                }, 1500);
            });
        }

        function updateSyncStatus(status) {
            appState.syncStatus = status;
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            
            dot.className = `status-dot ${status}`;
            
            const statusTexts = {
                disconnected: 'Disconnected',
                connecting: 'Connecting...',
                connected: 'Connected',
                syncing: 'Syncing...',
                error: 'Sync Error'
            };
            
            text.textContent = statusTexts[status] || 'Unknown';
        }

        // Event Listeners Setup
        function setupEventListeners() {
            const dragArea = document.getElementById('dragDropArea');
            const fileInput = document.getElementById('excelFile');

            dragArea.addEventListener('click', () => fileInput.click());
            dragArea.addEventListener('dragover', handleDragOver);
            dragArea.addEventListener('drop', handleDrop);
            dragArea.addEventListener('dragleave', handleDragLeave);
            fileInput.addEventListener('change', handleFileSelect);

            document.getElementById('searchInput').addEventListener('input', filterTasks);
        }

        // Application Initialization
        function initApp() {
            loadData();
            
            // Load sample data only if no tasks exist
            if (appState.tasks.length === 0 && appState.archivedTasks.length === 0) {
                loadSampleData();
            }
            
            updateCategoryFilter();
            updateToggleViewButton();
            updateArchiveToggleButton();
            
            // Set initial sort value
            const sortSelect = document.getElementById('sortSelect');
            if (sortSelect) {
                sortSelect.value = appState.currentSort;
            }
            
            sortAndRenderTasks();
            updateStats();
            setupEventListeners();
            
            // Apply theme
            const themeButton = document.querySelector('.theme-toggle');
            themeButton.textContent = appState.darkMode ? '☀️' : '🌙';
            
            // Start Tailscale sync if configured
            if (appState.tailscaleConfig.url) {
                startTailscaleSync();
            }
        }

        // Initialize the application when DOM is ready
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>